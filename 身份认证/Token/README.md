# Token

这里我们按`Token`是什么，为什么会出现来学习它。

## 什么是Token

`Token`是一种象征着身份的令牌，是访问资源接口(`API`)时所需的资源凭证，一个简单的`Token`一般由以下成分组成：`uid`(用户唯一的身份标识)、`time`(当前时间的时间戳)、`sign`(签名)。

并且它具有以下优点：

- **服务端无状态化**、可扩展性好
- **支持移动设备**
- 安全
- 支持跨程序调用

### 无状态

所有关于该`Token`的信息都附加在`Token`之中，服务器不保存任何信息，只负责验证。基于这一个原理，那么为了安全，这些信息必须要进行加密。由于加密与解密方都是服务器端所以我们选择对称加密算法(且对称加密算法比非对称加密算法快)

### Token的生成过程

`Token`在服务器端生成，当前端使用用户名/密码向服务器请求认证时，如果认证成功，那么服务器就会生成一个`Token`返回给前端。前端可以在每次请求时携带这个`Token`来证明自己的身份。

## 为什么要使用Token

为什么要使用它，即它解决了什么问题，对于我们前端开发者而言，它解决了以下三个问题：

- 由应用管理，避开了同源策略
- 避免`CSRF`攻击
- 无状态，可在多个服务中共享

## 关于Token的一些其他问题及解决方法

### 有效时间的设置

一个`Token`的有效期不可能是永久，不然会存在安全风险，那么多久的有效期合适呢？一般来说尽可能短比较好，但不能太短，一般这个时间控制在一周。

这里就存在一个问题，如果在用户正常操作的过程中，`Token`过期失效了怎么办？解决方法其实有两种：

1. 前沿`Session`的解决方法，在每次用户操作时，刷新这个`Token`的有效期时间。但这种方案存在的问题就是大量请求时，每次都需要刷新会产生很大的开销。
2. 使用`Refresh Token`，这个`Token`与原`Token`关联，当原`Token`未过期时，每次操作不进行任何操作；但当原`Token`过期时，就去验证这个`Refresh Token`的有效期：如果在有效期内，则申请一个新`Token`代替原`Token`，并重置关联；如果不在有效期内，则要求用户重新登录。(`Refresh Token`的有效期稍微要长于原`Token`)

### 无状态的同时的注意点

在使用无状态的`Token`时在服务器端会存在一些变化。服务器端虽然不再保存有效期内的`Token`了，但却要保存未到期却已注销了的`Token`。设想这样一个场景，如果一个`Token`未到期就被用户主动注销了，那么服务器端再次收到该有效期内`Token`(这里假设我们没做任何其他操作)时，就会认为其有效，继续沿用其身份。

当然不止上述一种解决方法，把这些解决方法总结起来主要分为两个方面：

- 前端控制：与前端协商，一旦用户注销成功，就必须丢弃本地的`Token`和`Refresh Token`，这样就保证了后端收到的`Token`一定是未注销的。
- 后端控制：此时说明前端不可控，那么此时我们要尽可能的缩短`Token`的有效期，而且必须在用户主动注销的情况下让`Refresh Token`无效。

[参考1——Token 认证的来龙去脉](https://juejin.im/post/5a6c60166fb9a01caf37a5e5#heading-6)
[JWT规范及其相关库](https://jwt.io/)
