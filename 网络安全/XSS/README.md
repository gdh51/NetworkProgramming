# XSS

`XSS(Cross-Site Scripting)`即跨站点脚本攻击，是一种通过在目标网站上注入恶意脚本，使之在用户浏览器上运行。(为了与`CSS`区别所以改名为`XSS`)

## XSS的危害

利用这些脚本，攻击者可以获取用户的敏感信息，如`Cookie`，`localStorage`等等，危害用户数据安全。

## 攻击原理

恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信任的，导致恶意脚本被执行。

## XSS类型分类

根据攻击的来源，XSS攻击可以分为三种类型：存储型、反射型、DOM型.

|类型|存储区*|插入点*|
|:-|:-|:-|
|存储型 XSS|后端数据库|HTML|
|反射型 XSS|URL|HTML|
|DOM 型 XSS|后端数据库/前端存储/URL|前端 JavaScript|

- **存储区**：恶意代码存放的位置
- **插入点**：由谁获取代码，并插入到网页上

### 存储型XSS

存储型XSS的攻击步骤为：

1. 攻击者将恶意代码提交到目标网站的数据库中。

2. 用户打开目标网站时，服务器从数据库取出数据拼接在HTML中返回给客户端

3. 客户端收到响应后进行解析，而混入其中的恶意代码也一同被解析。

这种攻击方式常见于有用户数据保存功能的网站，如论坛、评论、私信等。

### 反射型XSS

反射型XSS的攻击步骤为：

1. 攻击者构造出特殊的URL，其中包含恶意代码。

2. 用户打开含有恶意代码的URL时，服务器将恶意代码从URL中取出，拼接在HTML中返回给浏览器。

3. 客户端收到响应后进行解析，而混入其中的恶意代码也一同被解析。

>这种攻击方式与上面那种的区别为：存储型XSS的恶意代码存放在数据库，反射型XSS的恶意代码存放在URL中。

该种攻击方式常见于网站搜索、网页跳转链接(比如这里的[跳转链接](#%e5%8f%8d%e5%b0%84%e5%9e%8bxss))、还有你邮箱邮件中各种莫名其妙的链接

### DOM型XSS

`DOM`型`XSS`的攻击步骤为：

1. 攻击者构造出特殊的 `URL`，其中包含恶意代码。

2. 用户打开带有恶意代码的 `URL`。

3. 用户浏览器接收到响应后解析执行，前端 `JavaScript` 取出 `URL` 中的恶意代码并执行。

`DOM` 型 `XSS` 跟前两种 `XSS` 的区别：`DOM` 型 `XSS` 攻击中，取出和执行恶意代码**由浏览器端完成**，属于前端 `JavaScript` 自身的安全漏洞，而其他两种 `XSS` 都属于**服务端的安全漏洞**。

## 如何防御XSS攻击

由前面的攻击类型我们可以知道，XSS攻击的两个要素是：

1. **攻击者提交恶意代码**
2. **浏览器执行恶意代码**

针对第一种情况，我们可以在用户输入时，对其输入进行过滤：

### 输入过滤

对于输入过滤是有条件的，因为在不同的地方需要不同的输入过滤。

>假如我们只在前端进行过滤，那么攻击者完全可以直接构造请求绕过前端，提交到数据库；那么直接在数据库存入时进行过滤呢？也是不行的，因为我们不明确这个数据要用作什么，假如用户输入'1 > 3'，那么数据库存入前过滤为'1 \&gt; 3'，等到数据库返回给浏览器时，直接作为HTML内容时还能成功解析为'1 > 3'，但如果作为JS变量时，就未必能成功转义，如Vue模版。

但对于部分明确的输入类型还是可以放心的转义的，如电话、URL、邮箱、电话号码等。

### 预防存储型和反射性XSS攻击

针对输入过滤的不确定性，我们必须要通过第二点来进行防范。

存储型和反射型都是通过从数据库取出恶意代码后插入HTML中的，预防的方法有两种：

- **纯前端渲染**，数据与代码分隔
- 对**HTML**做充分的**转义**

#### 纯前端渲染

纯前端渲染的过程为：

1. 浏览器先加载一个静态HTML文件，文件中不包含任何数据

2. 浏览器执行HTML文件的JS，通过Ajax获取数据，然后进行数据填充。

在纯前端渲染过程中，必须明确告诉客户端：

1. 设置文本调用`.innerText`
2. 设置属性`.setAttribute`
3. 设置样式`.style`

这样浏览器就可以执行预期之内的代码。但是还是要注意DOM型XSS攻击的问题。

[预防DOM型XSS攻击](#%e9%a2%84%e9%98%b2dom%e5%9e%8b%e6%94%bb%e5%87%bb)

##### 前端渲染适用场景

适用于内部、系统管理、单页。对于有性能要求高、SEO需求的页面，还是需要拼接HTML。

#### 转义HTML

如果有拼接HTML的必要，那么就要采用合适的转义库，对HTML模版各处插入点进行转义。常用的模版引擎最多只做到了对下面列表中字符的简单转义：

字符|转义后的字符
-|-
`&`|`&amp;`
`<`|`&lt;`
`>`|`&gt;`
`"`|`&quot;`
`'`|`&#x27;`
`/`|`&#x2F;`

而对于CSS内联样式、内联JS、内联JSON、链接跳转等，以上方式并没有用，所以针对不同的上下文要使用相应的转义规则。

### 预防DOM型攻击

在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 `HTML` 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()`、`.innerText` 等。

如果用 `Vue/React` 技术栈，并且不使用 `v-html/dangerouslySetInnerHTML` 功能，就在前端 `render` 阶段避免 `innerHTML`、`outerHTML` 的 `XSS` 隐患。

DOM 中的内联事件监听器，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，`JavaScript` 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。

在链接跳转中，如`<a href="xxx"`或`location.href="xxx"`，要验证其内容，以`javascript:`开头的链接和其他的非法`schema`都要禁止(大小写不敏感)。

### 其他XSS防范措施

#### CSP策略

严格的`CSP`策略(`Content Security Policy`)可以在`XSS`防范中起到以下作用：

- 禁止加载外域代码，防止复杂的攻击逻辑。
- 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
- 禁止内联脚本执行（规则较严格，目前发现 `GitHub` 使用）。
- 禁止未授权的脚本执行（新特性，`Google Map` 移动版在使用）。
- 合理使用上报可以及时发现 `XSS`，利于尽快修复问题。

#### Cookie HttpOnly

设置后可以禁止浏览器端访问`Cookie`，但是这并没解决`XSS`问题

[严重参考](https://juejin.im/post/5bad9140e51d450e935c6d64#heading-9)