# TCP的拥塞控制

为了防止网络的拥塞现象，TCP提出了一系列的拥塞控制机制。它们最早由**慢启动**`(Slow start)`与**拥塞避免**`(Congestion avoidance)`组成，之后又新加入**快速重传**`(Fast retransmit)`和**快速恢复**`(Fast Recovery)`算法，再之后加入了选择性应答算法`(selective acknowledgement,SACK)`。

`TCP`的拥塞控制主要原理依赖于一个拥塞窗口`(cwnd)`来控制，窗口值的大小就代表能够发送出去的但还没有收到`ACK`的最大数据报文段(接收端还有一个用于流量控制的接收窗口`rwnd`)，显然窗口越大数据发送的速度就越快，但也有可能使得网络出现拥塞。如果窗口值为1，那么就简化为一个停等协议，每发送一个数据，都要等到对方的确认才能发送第二个数据包，显然数据传输效率低下。`TCP`的拥塞控制算法就是要在这两者之间权衡，选取最好的`cwnd`值，从而使得网络吞吐量最大化且不产生拥塞。

**由于需要考虑拥塞控制和流量控制两个方面的内容，因此TCP的真正的发送窗口=min(rwnd, cwnd)**。但是`rwnd`是由对端确定的，网络环境对其没有影响，所以在考虑拥塞的时候我们一般不考虑`rwnd`的值，我们暂时只讨论如何确定`cwnd`值的大小。关于`cwnd`的单位，在TCP中是以字节来做单位的，我们假设TCP每次传输都是按照MSS大小来发送数据的，因此你可以认为`cwnd`按照数据包个数来做单位也可以理解，所以有时我们说`cwnd`增加1也就是相当于字节数增加1个MSS大小。

## 慢启动

最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，`cwnd`初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，`cwnd`就增加1个MSS大小。这样`cwnd`的值就随着网络往返时间`(Round Trip Time,RTT)`呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。

## 拥塞避免

慢启动不可能无限增长，当它到了一个阶段时，TCP会使用一个名为慢启动门限的变量，当`cwnd`超过该值后，慢启动过程就结束了，进入拥塞避免状态。

拥塞避免的主要思想是加法增大，就是`cwnd`的增量算法由指数级增加变为加法级增加。此时当窗口中所有的报文段都被确认时，`cwnd`的大小加1，`cwnd`的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。

>上面讨论的两个机制都是没有检测到拥塞的情况下的行为，那么当发现拥塞了cwnd又该怎样去调整呢？

首先来看TCP是**如何确定网络进入了拥塞状态的**，TCP认为网络拥塞的主要依据是它重传了一个报文段。上面提到过，TCP对每一个报文段都有一个定时器，称为重传定时器(RTO)，当RTO超时且还没有得到数据确认，那么TCP就会对该报文段进行重传，当发生超时时，那么出现拥塞的可能性就很大，某个报文段可能在网络中某处丢失，并且后续的报文段也没有了消息，在这种情况下，TCP反应比较“强烈”：

1. 把`ssthresh`降低为`cwnd`值的一半
2. 把`cwnd`重新设置为1
3. 重新进入慢启动过程。

从整体上来讲，TCP拥塞控制窗口变化的原则是AIMD原则，即加法增大、乘法减小。可以看出TCP的该原则可以较好地保证流之间的公平性，因为**一旦出现丢包，那么立即减半退避**，可以给其他新建的流留有足够的空间，从而保证整个的公平性。

## 快速重传

其实TCP还有一种情况会进行重传：那就是收到3个相同的ACK。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行快速重传，快速重传做的事情有：

1. 把`ssthresh`设置为`cwnd`的一半
2. 把`cwnd`再设置为`ssthresh`的值(具体实现有些为`ssthresh+3`)
3. 重新进入拥塞避免阶段。

## 快速恢复

后来的“快速恢复”算法是在上述的“快速重传”算法后添加的，当收到3个重复ACK时，**TCP最后进入的不是拥塞避免阶段，而是快速恢复阶段**。快速重传和快速恢复算法一般同时使用。

快速恢复的思想是“**数据包守恒**”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是`cwnd`加1。如果能够严格按照该原则那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。

具体来说快速恢复的主要步骤是：

1. 当收到3个重复ACK时，把`ssthresh`设置为`cwnd`的一半，把`cwnd`设置为`ssthresh`的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。
2. 再收到重复的ACK时，拥塞窗口增加1。
3. 当收到新的数据包的ACK时，把`cwnd`设置为第一步中的`ssthresh`的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。

[参考](https://blog.csdn.net/itmacar/article/details/12278769)

## 提问

1. **一个 TCP 连接可以对应几个 HTTP 请求**
   在HTTP1.0中无长连接，1个TCP连接对应1个HTTP请求，而在HTTP1.1后对应多个，直至关闭连接。所以如果维持长连接，则可以对应多个，反之一个。

2. **一个 TCP 连接中 HTTP 请求发送可以一起发送么**
   在**HTTP1.X**阶段，单个TCP连接在**同一时刻只能处理一个请求**，即两个请求的生命周期不能重叠，任意两个请求从开始到结束的时间在同一个TCP连接中不能重叠。但我们可以通过设置`Pipelining`来解决这个问题(默认关闭)，但存在以下问题：
   - 代理服务器部分不能正确处理该模式
   - 连接头阻塞：假设建立TCP连接后，会发送多个请求，按Pipelining标准，返回的响应必须按序返回，如果前几个请求响应处理时间过久，那么会阻塞后面请求的响应。

   而在**HTTP2.0**阶段，支持多路复用，所以多个HTTP请求可以在同一个TCP连接中并行进行。

3. **浏览器对同一Host建立TCP连接到数量有没有限制？**
   有限制，一般对同一个域名建立TCP的个数限制在8个。(不同浏览器可能有区别)
