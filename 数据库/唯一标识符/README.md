## UUID(GUID)
`UUID`出现的目的，是为了让分布式系统可以不借助中心节点，就可以生成`UUID`来标识一些唯一的信息。`GUID`，是`Globally Unique Identifier`的缩写，跟`UUID`是同一个东西，只是来源于微软。

`UUID`的标准格式：`xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx`
A那个位置，代表版本号，由于`UUID`的标准实现有5个版本，所以只会是`1,2,3,4,5`
B那个位置，只会是`8,9,a,b`

UUID在发展过程中，为了适应不同的需要，产生了5个版本：

+ **uuid1**: 基于时间戳、机器MAC地址生成。由于使用MAC地址，可以保证全球范围的唯一性。
+ **uuid2**: 只基于时间戳，不常用。
+ **uuid3**: 基于`namespace`和一个自定义字符串，不常用。
+ **uuid4**: 只基于随机数，最常用，但不推荐，重复几率不太能让人接受。
+ **uuid5**: 只基于`namespace`，不常用。

为了确保其唯一性，其规范定义包含网卡MAC地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素。

缺点：
  1. 过长
  2. 无规律，降低数据库性能

## Snowflake雪花算法
优点：生成有顺序的id，提高数据库性能

### 组成
雪花算法解析结构为：
`0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000`
其中：
+ 1位标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以为0；

+ 41位时间戳部分，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，`(1L << 41) / (1000L 60 60 24 365) = 69`年；

+ 10位节点部分，Twitter实现中使用前5位作为数据中心标识，后5位作为机器标识，可以部署1024个节点；

+ 12位序列号部分，支持同一毫秒内同一个节点可以生成4096个ID；

`SnowFlake`算法生成的ID大致上是按照时间递增的，用在分布式系统中时，需要注意数据中心标识和机器标识必须唯一，这样就能保证每个节点生成的ID都是唯一的。或许我们不一定都需要像上面那样使用5位作为数据中心标识，5位作为机器标识，可以根据我们业务的需要，灵活分配节点部分，如：若不需要数据中心，完全可以使用全部10位作为机器标识；若数据中心不多，也可以只使用3位作为数据中心，7位作为机器标识。

[参考1](https://www.cnblogs.com/yanduanduan/p/10038345.html)
[参考2](https://juejin.im/post/5c75132f51882562276c5065?utm_source=tuicool&utm_medium=referral)